{"title":"Beyond Descriptive Modelling of Network Degrees: Tail-Realistic Preferential Attachment","markdown":{"headingText":"Networks","containsRefs":false,"markdown":"```{r}\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\nlibrary(paletteer)\nlibrary(Rcpp)\nlibrary(cowplot)\nlibrary(network)\nlibrary(networkDynamic)\nlibrary(ndtv)\nlibrary(ggraph)\nlibrary(intergraph)\nlibrary(ggplot2)\nlibrary(igraph)\nif(file.exists('phd/AppliedStats311025/scripts/funcs.R')){\n  source('phd/AppliedStats311025/scripts/funcs.R')\n}else if(file.exists('scripts/funcs.R')){\n  source('scripts/funcs.R')\n}\n\ninvisible(ggplot() + geom_blank())\nset.seed(1234)\ntheme_callout <- function() {\n  theme_minimal(base_family = \"Arial\", base_size = 14) +\n    theme(\n      # Transparent backgrounds for blending into the callout\n      plot.background = element_rect(fill = \"#432534\", color = NA),\n      panel.background = element_rect(fill = \"#432534\", color = NA),\n      legend.background = element_rect(fill = \"#432534\", color = NA),\n      legend.box.background = element_rect(fill = \"#432534\", color = NA),\n      \n      # Text styling for dark background\n      plot.title = element_text(color = \"#efd6ac\", size = 20, face = \"bold\", hjust = 0.5),\n      plot.subtitle = element_text(color = \"#efd6ac\", size = 14, hjust = 0.5),\n      plot.caption = element_text(color = \"#efd6ac\", size = 10, hjust = 1),\n      axis.title = element_text(color = \"#efd6ac\", face = \"bold\"),\n      axis.text = element_text(color = \"#efd6ac\"),\n      \n      # Gridlines (light wheat color for contrast)\n      panel.grid.major = element_line(color = \"#efd6ac55\", size = 0.3),\n      panel.grid.minor = element_blank(),\n      \n      # Legend\n      legend.title = element_text(color = \"#efd6ac\", face = \"bold\"),\n      legend.text = element_text(color = \"#efd6ac\"),\n      \n      # Axis lines and ticks (slightly lighter for visibility)\n      axis.line = element_line(color = \"#efd6ac88\"),\n      axis.ticks = element_line(color = \"#efd6ac88\"),\n      \n      # Tight margins (avoid white edges)\n      plot.margin = margin(0, 0, 0, 0)\n    ) \n}\n\ntheme_presentation <- function() {\n  theme_minimal(base_size = 14) +\n    theme(\n      rect = element_rect(fill = \"transparent\"),\n      # Backgrounds\n      plot.background = element_rect(fill = \"transparent\", color = NA),\n      panel.background = element_rect(fill = \"transparent\", color = NA),\n      legend.background = element_rect(fill = \"transparent\", color = NA),\n      \n      # Text\n      plot.title = element_text(color = \"#c44900\", size = 20, face = \"bold\", hjust = 0.5),\n      plot.subtitle = element_text(color = \"#432534\", size = 14, face = \"italic\", hjust = 0.5),\n      plot.caption = element_text(color = \"#432534\", size = 10, hjust = 1),\n      axis.title = element_text(color = \"#04151f\", face = \"bold\"),\n      axis.text = element_text(color = \"#04151f\"),\n      \n      # Gridlines\n      panel.grid.major = element_line(color = \"#432534\", size = 0.3),\n      panel.grid.minor = element_blank(),\n      \n      # Legend\n      legend.title = element_text(color = \"#04151f\", face = \"bold\"),\n      legend.text = element_text(color = \"#432534\"),\n      \n      # Axis lines and ticks\n      axis.line = element_line(color = \"#04151f\"),\n      axis.ticks = element_line(color = \"#04151f\")\n    )\n}\n\n```\n\n\n\n:::{.notes}\n\n- Networks are everywhere\n- Fairly simple and can represent complex systems\n- Objects represented by the nodes\n- Relationships represented by edges\n\n- Key feature is the degree\n- Each node has in/out-degree representing the number of incoming and outgoing edges\n\n:::\n\n\n\n:::{.columns}\n\n::::{.column width=\"50%\"}\n\n### Examples\n\n>- Instagram\n>- Flights\n>- Protein Interactions\n>- Citations\n>- CRAN\n\n::::\n\n::::{.column width=\"50%\"}\n\n\n```{r, out.width=\"100%\"}\n#| fig-width: 3\n#| fig-asp: 0.5\n\n\nset.seed(1234)\ng = igraph::sample_pa(5, power=0.2, m=2)\n\n\nggraph(g, layout='stress') +\n  geom_edge_link0()+\n   geom_edge_link2(arrow = arrow(length=unit(0.1,'inches')), end_cap = circle()) +\n   geom_node_point(size=5, color='#432534') + geom_node_text(aes(label=1:vcount(g)), color='#efd6ac')+\n    theme_void()\n\ndf1 = data.frame(Node=1:vcount(g), 'In-Degree' = igraph::degree(g, mode='in'), 'Out-Degree'  =igraph::degree(g, mode='out'))\n\n\nknitr::kable(df1)\n\n```\n\n\n\n\n\n::::\n\n\n:::\n\n## Network Data\n\n:::{.notes}\n\n- Rarely have full temporal data, usually only a snapshot\n- Full evolution is too constly or impossible to observe\n- We often instead choose to study properties of these snapshots\n- e.g. the degrees\n\n\n:::\n\n:::{.columns}\n::::{.column width=\"50%\" height=\"50%\"}\n:::::{.callout-tip title=\"Full Evolution\"}\n```{r, fig.height=\"100px\", fig.asp=1, results='asis'}\n#| label: anim0\n#| fig-asp: 1\nn =  25\nout.seq = rpois(n, 1) + 1\ng_igraph <- igraph::sample_pa(n, directed = FALSE, out.seq = out.seq )\n\n\nel = as_edgelist(g_igraph)\npag <- network.initialize(n)\n\nadd.edges.active(pag, tail = el[,2], head=el[,1], onset = 2:(nrow(el)+1), terminus = rep(Inf, nrow(el)))\nactivate.vertices(pag, onset=1:n, terminus = rep(Inf,n))\n\nslice.par<-list(start=1,end=n,interval=1,\n                aggregate.dur=1,rule='earliest')\nreconcile.vertex.activity(pag)\nreconcile.edge.activity(pag)\n\n\nlayout_static <- gplot.layout.kamadakawai(pag, layout.par = NULL)\nnetwork::set.vertex.attribute(pag, \"x\", layout_static[,1])\nnetwork::set.vertex.attribute(pag, \"y\", layout_static[,2])\ncompute.animation(pag,\n                  seed.coords = layout_static,\n                  animation.mode = 'useAttribute',\n                  slice.par = list(start = 1, end = n, interval = 1, aggregate.dur = 1, rule = 'latest'))\n\n\nrender.d3movie(pag,\n               verbose = FALSE,\n               output.mode = 'inline',\n               d3.options = list(animateOnLoad=TRUE, slider=FALSE, durationControl=FALSE, margin=list(x=0,y=0),\n                                 ani.height=100, ani.width=100, loop=TRUE),\n               vertex.col = '#c44900',\n               edge.col = '#efd6ac',\n               displaylabels = FALSE,\n               bg = NA,\n               vertex.cex = 1,\n               vertex.lwd = 0,\n               durationControl = FALSE,\n               ani.height = 100,\n               ain.width=100,\n               loop=TRUE,\n               slice.par = list(start = 1, end = n, interval = 1, aggregate.dur = 1, rule = 'latest'))\n\n\n```\n:::::\n\n\n>- Often unavailable or too costly to extract\n>- Contains a lot of information\n> $~$\n\n::::\n\n::::{.column width=\"50%\"}\n:::::{.callout-tip title=\"Snapshot\" height=\"50%\"}\n```{r, fig.asp=0.55, out.width=\"100%\"}\n\nggraph(g_igraph, layout='stress') + geom_edge_link2(color='#efd6ac') + geom_edge_link0(color='#efd6ac', size=1) + \n  geom_node_point(color='#c44900') + theme_void()\n\n```\n:::::\n\n>- More often available\n>- Much easier to work with\n>- Can still study key properties e.g. degrees\n\n::::\n:::\n\n\n## The scale-free debate\n\n:::{.notes}\n- A lot of discussion over the shape of real degree distributions\n- Many claim a lot of real networks are \"scale-free\"\n- Others disagree, claiming unrealistic expectations\n- Literature doesn't even agree on the definition of scale-free\n\n- We will be using the most general definition, regular variation\n:::\n\n**There has been a *heated* debate over the presence of scale-free networks in reality.**\n\n::::{.columns}\n\n::: {.column width=\"45%\"}\n:::{.callout-tip title=\"Scale-free Degree Distribution --- Orginal scale\"}\n```{r, style=\"margin-left:auto; margin-right:auto; display:block;\", cache=TRUE}\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\nlibrary(igraph)\nlibrary(ggplot2)\ng = sample_pa(1e5, m=1)\ndegs = degree(g, mode='in') + 1\n\nggplot(twbfn::deg_surv(degs)) + geom_point(aes(x=degree, y=surv), color = '#efd6ac') + ylim(1e-5,1) + theme_callout()\n\n```\n:::\n:::\n:::{.column width=\"10%\"}\n:::\n::: {.column width=\"45%\"}\n:::{.callout-tip title=\"Scale-free Degree Distribution --- Log scale\"}\n```{r, cache=TRUE}\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\nlibrary(igraph)\nlibrary(ggplot2)\nggplot(twbfn::deg_surv(degs)) + geom_point(aes(x=degree, y=surv), color = '#efd6ac') +\nscale_x_log10() + scale_y_log10(limits=c(1e-5,1))+\ngeom_smooth(method='lm', formula=y~x, se=FALSE, aes(x=degree, y=surv), color = '#c44900', lty=2)+\ntheme_callout() \n\n```\n:::\n:::\n::::\n\nSeveral definitions of scale-free in the literature\n\n:::{.columns}\n::::{.column width=\"33%\"}\n[**Heavier than exponential**]{.r-stack}\n\n$$\n\\bar F (k) \\gg e^{-ck}\n$$\n\n::::\n::::{.column width=\"34%\"}\n[**Power-law**]{.r-stack}\n$$\n\\bar F(k) \\sim k^{-\\gamma}\n$$\n\n::::\n::::{.column width=\"33%\"}\n[**Regularly varying tail**]{.r-stack}\n$$\n \\bar F(k) = k^{-\\gamma}\\mathcal L (k)\n$$\n::::\n\n:::\n\n\n\n\n\n## Modelling the degrees\n\n:::{.notes}\n\n- Lots of methods used to study these degrees\n\n1. Power law i.e. straight line on a log-log plot\n  - Simple, Easy to do\n  - Quite restrictive\n2. Modelling the tail using a Generalised Pareto\n  - Much more flexible but only gain information about the tail\n  - How do we pick the threshold?\n3. Piecewise model\n  - Power-law like for the body\n  - Generalised Pareto for the tail\n  - Lets you model the whole distribution and $u$ becomes an actual parameter\n\nLet's look at one of those methods.\n:::\n\n\n:::{.columns}\n::::{.column width=33%}\n#### Power Law\n```{r, fig.asp=1, out.width=\"75%\", fig.dpi=50, cache=TRUE}\n#| fig-width: 4\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\n\ndat_list = readRDS('results/dat_list.rds')\nasc = dat_list[[1]]\n\nasc_surv = twbfn::deg_surv(counts_to_degs(asc))\n\na = 1.8\nx = 1:40\ny = x^-a / (sum((1:1e4)^-a))\n\nasc_plt = ggplot()+ geom_line(data=NULL,aes(x=x, y=y), colour='red') + geom_point(data=asc_surv,aes(x=degree, y=surv)) + scale_x_log10() + scale_y_log10(limits=c(min(asc_surv[-nrow(asc_surv),2]),1))+theme_presentation() + xlab('Degree') + ylab('Survival')\n\n\nprint(asc_plt)\n```\n\n>$$\nK\\sim \\text{Pareto}(\\gamma)\n$$\n>$$\n~\n$$\n> Estimate $\\gamma$\n\n\n::::\n::::{.column width=33%}\n#### Tail Estimation\n\n```{r, fig.asp=1, out.width=\"75%\", fig.dpi=50, cache=TRUE}\n#| fig-width: 4\n\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\nfl = dat_list[[8]]\nfl_surv = twbfn::deg_surv(counts_to_degs(fl))\nfl_plt = ggplot() + geom_point(data=fl_surv,aes(x=degree, y=surv)) + scale_x_log10() + scale_y_log10(limits=c(min(fl_surv[-nrow(fl_surv),2]),1))\n\nx = 50:500\ny = evd::pgpd(x, loc=50, scale=43.8, shape = -0.1157, lower.tail=F)*fl_surv$surv[fl_surv$degree>=50][1]\nfl_plt = fl_plt + geom_line(data=NULL,aes(x=x, y=y), colour='red')+theme_presentation() + xlab('Degree') + ylab('Survival')\nfl_plt\n```\n\n>$$\nK|K>u \\sim \\text{GP}(\\xi, \\sigma)\n$$\n>$$\n~\n$$\n> Estimate $(\\xi,\\sigma)$\n\n::::\n::::{.column width=33%}\n#### Piecewise Model\n```{r, fig.asp=1, cache=TRUE, echo=FALSE,results='hide',fig.keep='all', out.width=\"75%\", fig.dpi=50}\n#| fig-width: 4\nlibrary(crandep)\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\nrea = dat_list[[10]]\nrea_surv = twbfn::deg_surv(counts_to_degs(rea))\nrea_plt = ggplot() + geom_point(data=rea_surv,aes(x=degree, y=surv)) + scale_x_log10() + scale_y_log10(limits=c(min(rea_surv[-nrow(rea_surv),2]),1))\n\nrea_counts= twbfn::deg_count(counts_to_degs(rea))\nrea_counts$degree = as.integer(rea_counts$degree)\nrea_counts$count = as.integer(rea_counts$count)\nnames(rea_counts) = c('x','count')\nrea_fit = mcmc_mix2_wrapper(rea_counts, seed=3234L,iter=1000L, u_max=100L, burn=1000L)\n\nrea_plt  = rea_plt + geom_line(data=rea_fit$fitted, aes(x=x, y=S_med), col='red') + geom_vline(aes(xintercept = median(rea_fit$pars$u)), lty=2, col='red') + xlab('Degree') + ylab('Survival')\n\nrea_plt+theme_presentation()\n\n```\n\n>$$\nK|K< u \\sim \\text{Pareto}(\\gamma)\n$$\n>$$\nK|K>u \\sim \\text{GP}(\\xi, \\sigma)\n$$\n> Estimate $(\\gamma, u, \\xi, \\sigma)$\n::::\n\n\n\n:::\n\n\n## Discrete Piecewise Model\n\n:::{.notes}\nThis model, used by Clement and some collaborators\n\n- Uses something like a power law for the body but with some added flexibility\n  - $\\theta$ measures how straight the line is i.e. how close to power-law the body is\n- Uses a discretisation of the GP for the tail\n\n:::\n\n:::{.columns}\n\n\n::::{.column width=25%}\n```{r, fig.asp=1, cache=TRUE, echo=FALSE,results='hide',fig.keep='all', out.width=\"90%\", fig.dpi=50}\n#| fig-width: 4\nrea_plt+theme_presentation()\n```\n::::\n\n::::{.column width=5%}\n::::\n\n::::{.column width=70%}\n**Zipf-Polylog**\n\n>$$\nf(k) \\propto k^{-\\alpha} \\theta^k, \\qquad k=1, 2, \\ldots, u\n$$\n\n**Integer Generalised Pareto**\n\n>$$\nF(k)= 1-\\left(1+\\frac{\\xi(k-u)}{\\sigma +\\xi u}\\right)_+^{-1/\\xi}, \\qquad k=u+1,\\ldots\n$$\n::::\n:::\n\nUsing this model @Lee24 found that networks often have a heavy tail but not quite as heavy as implied by the body.\n\n## Why care about scale-freeness?\n\n:::{.notes}\n\n- Why this obsession with scale-freeness and power-laws\n- People jump from 'looks like a power law' to claiming preferential attachment\n  - rich-get-richer\n- This only works one way PA -> power law not the other way round\n\n- Other than these claims the modelling of degrees is usually descriptive\n- We learn nothing about how the network grew.\n\n\n:::\n\n**Many use *scale-freeness* of a network to justify the mechanics behind the network's growth.**\n\n>Preferential Attachment (rich-get-richer) $\\Rightarrow$ Power-law degree distribution\n\n::::{.fragment}\nbut\n\n>Power-law degree distribution $\\nRightarrow$ Preferential Attachment (rich-get-richer)\n\n**This is fairly common as modelling the degrees does not generally inform the network growth.**\n\n::::\n\n\n\n\n\n## Preferential Attachment\n\n:::{.notes}\n\nNow lets take a look at that preferential attachment model so many love to claim\n- Usually called the Barabási-Albert model or Yule-Simon\n- Features a rich-get-richer mechanism \n  - The higher your degree the more likely you are to get more connections\n\n- This produces a power law with exponent 2, explaining why so many people like to claim a power law so they can use this model\n\n- However, in reality the behaviour of degree distributions is much more nuanced\n- We look to make this model more general\n\n:::\n\n:::::{.columns}\n::::{.column width=30%}\n\n:::{.callout-tip title=\"Example\"}\n```{r, fig.height=\"100px\", fig.asp=1, results='asis'}\n#| label: anim1\nn =  50\ng_igraph <- igraph::sample_pa(n, directed = FALSE)\n\n\nel = as_edgelist(g_igraph)\npag <- network.initialize(n)\n\nadd.edges.active(pag, tail = el[,2], head=el[,1], onset = 2:(nrow(el)+1), terminus = rep(Inf, nrow(el)))\nactivate.vertices(pag, onset=1:n, terminus = rep(Inf,n))\n\nslice.par<-list(start=1,end=n,interval=1,\n                aggregate.dur=1,rule='earliest')\nreconcile.vertex.activity(pag)\nreconcile.edge.activity(pag)\n\n\nlayout_static <- gplot.layout.kamadakawai(pag, layout.par = NULL)\nnetwork::set.vertex.attribute(pag, \"x\", layout_static[,1])\nnetwork::set.vertex.attribute(pag, \"y\", layout_static[,2])\ncompute.animation(pag,\n                  seed.coords = layout_static,\n                  animation.mode = 'useAttribute',\n                  slice.par = list(start = 1, end = n, interval = 1, aggregate.dur = 1, rule = 'latest'))\n\n\nrender.d3movie(pag,\n               verbose = FALSE,\n               output.mode = 'inline',\n               d3.options = list(animateOnLoad=TRUE, slider=FALSE, durationControl=FALSE, margin=list(x=0,y=0),\n                                 ani.height=100, ani.width=100, loop=TRUE),\n               vertex.col = '#c44900',\n               edge.col = '#efd6ac',\n               displaylabels = FALSE,\n               bg = NA,\n               vertex.cex = 1,\n               vertex.lwd = 0,\n               durationControl = FALSE,\n               ani.height = 100,\n               ain.width=100,\n               loop=TRUE,\n               slice.par = list(start = 1, end = n, interval = 1, aggregate.dur = 1, rule = 'latest'))\n\n\n```\n:::\n::::\n\n::::{.column width=70%}\n### Steps\n\n\n\n:::{.blockquote}\n1. Node added to network\n2. Connects to $m$ existing nodes with weights $\\pi_i$:\n\n$$\n\\pi_i = \\left. k_i \\middle/ \\sum_j k_j \\right.\n$$\nwhere $k_i$ is degree of node $i$.\n:::\n\n::::\n:::::\n\n**Results in a power-law degree distribution**\n\n>$$\n\\bar F(k)\\sim k^{-2}\n$$\n\n\n\n## General Preferential Attachment\n\n:::{.notes}\n- We make it more general by simply changing the $k+1$ to be instead a general function of the in-degree.\n- This should allow for much more flexible behaviour that can potentially match that of real networks\n\n- But, how do we study this given how general it is\n\n:::\n\n:::::{.columns}\n::::{.column width=30%}\n\n:::{.callout-tip title=\"Example\"}\n```{r, fig.height=\"100px\", fig.asp=1, results='asis'}\n#| label: anim2\n\n\nn =  50\ng_igraph <- sample_pa(n, directed = FALSE)\n\n\nel = as_edgelist(g_igraph)\npag <- network.initialize(n)\n\nadd.edges.active(pag, tail = el[,2], head=el[,1], onset = 2:(nrow(el)+1), terminus = rep(Inf, nrow(el)))\nactivate.vertices(pag, onset=1:n, terminus = rep(Inf,n))\n\nslice.par<-list(start=1,end=n,interval=1,\n                aggregate.dur=1,rule='earliest')\nreconcile.vertex.activity(pag)\nreconcile.edge.activity(pag)\n\n\nlayout_static <- gplot.layout.kamadakawai(pag, layout.par = NULL)\nnetwork::set.vertex.attribute(pag, \"x\", layout_static[,1])\nnetwork::set.vertex.attribute(pag, \"y\", layout_static[,2])\ncompute.animation(pag,\n                  seed.coords = layout_static,\n                  animation.mode = 'useAttribute',\n                  slice.par = list(start = 1, end = n, interval = 1, aggregate.dur = 1, rule = 'latest'))\n\n\nrender.d3movie(pag,\n               verbose = FALSE,\n               output.mode = 'inline',\n               d3.options = list(animateOnLoad=TRUE, slider=FALSE, durationControl=FALSE, margin=list(x=0,y=0),\n                                 ani.height=100, ani.width=100, loop=TRUE),\n               vertex.col = '#c44900',\n               edge.col = '#efd6ac',\n               displaylabels = FALSE,\n               bg = NA,\n               vertex.cex = 1,\n               vertex.lwd = 0,\n               durationControl = FALSE,\n               ani.height = 100,\n               ain.width=100,\n               loop=TRUE,\n               slice.par = list(start = 1, end = n, interval = 1, aggregate.dur = 1, rule = 'latest'))\n\n\n```\n:::\n::::\n\n::::{.column width=70%}\n### Steps\n\n\n\n:::{.blockquote}\n1. Node added to network\n2. Connects to $m$ existing nodes with weights $\\pi_i$:\n\n$$\n\\pi_i = \\left. b(k_i) \\middle/ \\sum_j b(k_j) \\right.\n$$\nwhere $k_i$ is degree of node $i$.\n:::\n\n::::\n\nHow do we study the degree distribution of this?\n\n:::::\n\n## Aims\n\n:::{.notes}\nLet us first go over what we want to do\n:::\n\n:::{.v-center-container}\n- Connect preference function to tail behaviour of limiting degree distribution\n- Propose a flexible tail-realistic model for networks degrees\n- Obtain information about network growth from degrees alone of real data\n:::\n\n## Starting with a branching process\n\n:::{.notes}\nTo study the generalised model\n\n- we can consider the following branching process\n\n:::\n\nConsider the GPA model when $m=1$, and a continuous time branching process $\\zeta(t)$ where:\n\n- $\\zeta(0)=0$\n- $\\zeta(t)$ driven by Markovian pure birth \n\n$$\n\\Pr(\\zeta(t+\\text{d}t) = k+1 | \\zeta(t) =k) = b(k) \\text{d}t + o(\\text{d}t)\n$$\n\nThis pure birth process corresponds to the growth of an individual nodes degree.\n\n\n## Equivalence to GPA\n\n:::{.notes}\n\nWe can show that this is equivalent to the GPA when m=1 by:\n\n- constructing a tree\n- each node gives birth at rate according to b of its in-degree\n\n:::\n\nConstruct the tree $\\Upsilon(t)$ determined by $\\zeta(t)$ such that:\n\n- $\\Upsilon(0)=\\left\\{\\emptyset\\right\\}$\n- Each node, $x$, in $\\Upsilon(t)$ gives birth at rate $b(\\text{deg}(x, \\Upsilon(t)))$ \n\nDenote $\\Upsilon(t)_{\\downarrow x}$ the tree when treating $x$ as the root.\n\n**This construction is equivalent to the GPA model with $m=1$ and preference function $b(\\cdot)$**\n\n## A limiting result\n\n\n:::{.notes}\n\nRudas studied this and with results from CTBP established the following result\n  - for some characeteristic function, phi, we have that\n  - where rho hat is the laplace transform of the density of the point process associated with the CTBP\n:::\n\n@rudas07 states that for a given characteristc function $\\phi(\\cdot)$\n\n$$\n\\lim_{t\\rightarrow\\infty} \\frac{1}{\\left|\\Upsilon(t)\\right|}\\sum_{x\\in\\Upsilon(t)}\\phi(\\Upsilon(t)_{\\downarrow x}) = \\lambda^* \\int_0^\\infty e^{-\\lambda^*}\\mathbb E \\left[\\phi(\\Upsilon(t))\\right]\\text{d}t\n$$\n\nwhere $\\lambda^*$ satisfies\n\n$$\n\\hat\\rho(\\lambda^*) = \\int_0^\\infty e^{-\\lambda^*t}\\rho(t)\\text{d}t = 1\n$$\n\nand $\\rho(t)$ is the density of the point process associated with $\\zeta(t)$.\n\n## Getting the degree distribution\n\n:::{.notes}\n\nUsing the fact that we can write the empirical tail of the degrees as\n- In the limit of time going to infinity this empirical distribution we can get the tail of the limiting degree distribution\n\nThis gets us quite an elegant form, which looks fairly simple\n\nhow do we study this\n\n:::\n\nWe can write the tail of the degree distribution at time $t$ as:\n\n$$\n\\frac{\\sum_{x\\in\\Upsilon(t)} \\mathbb I\\left\\{\\text{deg}(x, \\Upsilon(t)\\downarrow x)>k \\right\\} }{\\left|\\Upsilon(t)\\right|}\n$$\n\nand so the tail of the limiting degree distribution as $t\\rightarrow \\infty$ is:\n\n$$\n\\bar F(k) = \\lim_{t\\rightarrow\\infty} \\frac{\\sum_{x\\in\\Upsilon(t)} \\mathbb I\\left\\{\\text{deg}(x, \\Upsilon(t)_{\\downarrow x})>k \\right\\} }{\\left|\\Upsilon(t)\\right|}\n$$\n\nSo we can now use the previous result to obtain:\n\n$$\n\\bar F(k) = \\lambda^* \\int_0^\\infty e^{-\\lambda^*t}\\mathbb E\\left[\\mathbb I\\left\\{\\text{deg}(x, \\Upsilon(t)_{\\downarrow x})>k \\right\\}\\right]\\text{d}x\n$$\n\n\n---\n\nThrough fairly simple calculations we get:\n\n$$\n\\bar F(k) = \\prod_{i=0}^k\\frac{b(i)}{\\lambda^*+b(i)}\n$$\n\nwhere $\\lambda^*$ satisfies \n\n$$\n\\hat \\rho(\\lambda^*) = \\sum_{k=0}^\\infty \\prod_{i=0}^k\\frac{b(i)}{\\lambda^* + b(i)} = 1\n$$\n\n**What effect does $b(\\cdot)$ have on this degree distribution, particularly in the tail?**\n\n## Studying the tail{.r-fit-text}\n\n:::{.notes}\n\nWe would like to pay close attention to the largest degrees as in many networks these happen to be very influential\n- The perfect application of extreme value theory\n\nOften people will just use continuous methods to study these dergee distributions either by assuming they will just work\n- or adding a jiggle to the points and then applying the continuous methods\n\nWe want to be more precise and use machinery made for discrete data\n\n:::\n\n**We want to pay careful attention to the extreme values**\n\n>Studies of empirical degrees often use methods from continuous extremes\n\nAs this is a discrete distribution we need some new machinery.\n\n## Continuous Extremes Recap\n\n### Maximum Domains of Attraction (MDA)\n\n:::{.columns}\n::::{.column width=\"50%\"}\n[**Fréchet (heavy tailed)**]{.r-stack}\n\n>$$\n\\bar F(x) = x^{-\\gamma} \\mathcal L(x)\n$$\ne.g. Pareto, Cauchy, Lévy\n\n\n::::\n\n::::{.column width=\"50%\"}\n[**Gumbel (light-tailed)**]{.r-stack}\n\n>$$\n\\lim_{x\\rightarrow\\infty}\\frac{\\bar F (x + t a(x))}{\\bar F(x)}= e^{-t}\n$$\ne.g. Exponential, Normal, Gamma\n::::\n\n\n- The  Fréchet is equivalent to regular variation with tail-index $\\gamma$\n- Power-law falls into the  Fréchet MDA with $\\mathcal L(x)=1$\n\n*All continuous distributions with infinite right endpoint fall into one of these.*\n\n**Many discrete distributions don't satisfy the conditions to belong to an MDA**\n:::\n\n\n## Discrete Extremes\n\n:::{.notes}\nWhen we enter the field of discrete data things become harder so\n\n- Shimura provides us with this result regarding the MDA of discrete distributions\n\n- We can still use the previous methods to categorise the distributions (if they can be)\n  - this is often difficult or unattainable\n  - and quite often a discrete distribution cannot be categorised using these methods\n\n\n\n:::\n\n@shimura12 uses the following quantity to categorise discrete distributions\n$$\n\\Omega(F, k) = \\left(\\log \\frac{\\bar F(k+1)}{ \\bar F(k+2)}\\right)^{-1} - \\left(\\log \\frac{\\bar F(k)}{ \\bar F(k+1)}\\right)^{-1}\n$$\n\n:::{.columns}\n::::{.column width=\"33%\"}\n [**Fréchet**]{.r-stack}\n\n>$$\n\\lim_{k\\rightarrow\\infty} \\Omega(F,k) = 1/\\alpha\n$$\n>*and* \n>$$\n\\lim_{k\\rightarrow\\infty} \\frac{\\bar F(k+1)}{\\bar F(k)} = 1\n$$\n\n::::\n::::{.column width=\"33%\"}\n[**Gumbel**]{.r-stack}\n\n>$$\n\\lim_{k\\rightarrow\\infty} \\Omega(F,k) = 0\n$$\n>*and*\n>$$\n\\lim_{k\\rightarrow\\infty} \\frac{\\bar F(k+1)}{\\bar F(k)} = 1\n$$\n::::\n\n\n\n::::{.column width=\"33%\"}\n[**Recoverable to Gumbel**]{.r-stack}\n\n>$$\n\\lim_{k\\rightarrow\\infty} \\Omega(F,k) = 0\n$$\n>*and*\n>$$\n\\lim_{k\\rightarrow\\infty} \\frac{\\bar F(k+1)}{\\bar F(k)} \\neq 1\n$$\n::::\n\n:::\n\n## Analysing GPA degrees\n\n:::{.notes}\nPlugging in the limitng survival from earlier can an show that:\n\n- Provided the preference is unbounded\n  - falls in the  Fréchet if and only if \"eventually linear\"\n  - falls into the Gumbel if and only if this limit goes to zero\n- If it is indeed bounded then it falls into neither but is recoverable to the Gumbel\n  - i.e. it is close to being in the Gumbel\n\n\n**Examples**\n\nWe look at three possible simple forms of preference function\n- The first we have seen before and know how it behaves, we can see that this agrees\n\n:::\n\nNow we can use the limiting survival function of a GPA model to show that:\n\n$$\n\\lim_{k\\rightarrow\\infty} \\Omega(F,k)= \\begin{cases} \\lim_{k\\rightarrow \\infty}\\frac{b(k+1)-b(k)}{\\lambda^*}, &\\text{when } b(k) \\rightarrow \\infty\\\\\n0, &\\text{otherwise}\n\\end{cases}\n$$\n\nand therefore for $b(k)\\rightarrow\\infty$ as $k\\rightarrow\\infty$\n\n>- $\\bar F (k)$ is regularly varying (**Fréchet MDA**) if and only if $\\lim_{k\\rightarrow \\infty}[b(k+1)-b(k)] = \\nu >0$, in which case the tail index is $\\lambda^*/\\nu$ \n>- $\\bar F(k)$ is light-tailed (**Gumbel MDA**) if and only if $\\lim_{k\\rightarrow \\infty}[b(k+1)-b(k)]=0$.\n\n\n*Note that if $\\lim_{k\\rightarrow\\infty} b(k)<\\infty$, then $\\bar F(k)$ is recoverable to the Gumbel MDA.*\n\n\n--- \n\n\n```{r}\nx = seq(0,50,length.out=100)\ny1 = twbfn::ppa_pref(x, 0.2, 1, 1e4)\ny2 = twbfn::ppa_pref(x, 1, 1, 1e4)\ny3 = twbfn::ppa_pref(x, 0, 1, 1e4)\n\ndf = data.frame(x=x, y1,y2,y3)\n\np1 = ggplot(data=df, aes(x=x)) + geom_line(aes(y=y1), colour='darkred',linewidth=3)+ theme_void() +theme(aspect.ratio = 1,plot.background = element_rect(fill=NA, color = NA),panel.background = element_rect(fill=NA, color = NA),axis.title=element_blank())\np2 = ggplot(data=df, aes(x=x)) + geom_line(aes(y=y2), colour='darkred',linewidth=3)+ theme_void() +theme(aspect.ratio = 1,plot.background = element_rect(fill=NA, color = NA),panel.background = element_rect(fill=NA, color = NA),axis.title=element_blank())\np3 = ggplot(data=df, aes(x=x)) + geom_line(aes(y=y3), colour='darkred',linewidth=3)+ theme_void() +theme(aspect.ratio = 1,plot.background = element_rect(fill=NA, color = NA),panel.background = element_rect(fill=NA, color = NA),axis.title=element_blank())\n```\n\n\n### Examples\n:::{.columns}\n::::{.column width=\"33%\"}\n\n>**Barabási-Albert (BA)**\n>$$\nb(k) = k+1\n>$$\n>```{r}\n>p2\n>```\n>$$\n\\lim_{k\\rightarrow\\infty} \\Omega(F,k) = 1/\\lambda^* = 1/2\n>$$\n>$$\n\\lim_{k\\rightarrow\\infty} \\frac{\\bar F(k+1)}{\\bar F(k)} = 1\n>$$\n> Fréchet, with index 2\n::::\n::::{.column width=\"33%\"}\n\n>**Polynomial**\n>$$\nb(k) = (k+1)^\\alpha, \\quad \\alpha\\in (0,1)\n>$$\n>```{r}\n>p1\n>```\n>$$\n\\lim_{k\\rightarrow\\infty} \\Omega(F,k) = 0\n>$$\n>$$\n\\lim_{k\\rightarrow\\infty} \\frac{\\bar F(k+1)}{\\bar F(k)} = 1\n>$$\n>Gumbel \n\n::::\n\n\n::::{.column width=\"33%\"}\n\n>**Uniform**\n>$$\nb(k) = c, \\quad c>0\n$$\n>```{r}\n>p3\n>```\n>$$\n\\lim_{k\\rightarrow\\infty} \\Omega(F,k) = 0\n$$\n>$$\n\\lim_{k\\rightarrow\\infty} \\frac{\\bar F(k+1)}{\\bar F(k)} \\neq 0\n$$\n>Recoverable to Gumbel \n::::\n\n:::\n\n## What we have learned so far.\n\n### Main result\n\n>- $\\bar F (k)$ is regularly varying (**Fréchet MDA**) if and only if $\\lim_{k\\rightarrow \\infty}[b(k+1)-b(k)] = \\nu >0$, in which case the tail index is $\\lambda^*/\\nu$ \n>- $\\bar F(k)$ is light-tailed (**Gumbel MDA**) if and only if $\\lim_{k\\rightarrow \\infty}[b(k+1)-b(k)]=0$.\n\n- For degree distribution to be heavy tailed and be the result of a GPA model, preference must be eventually \"linear\" like in the BA model\n- Empirical degree distributions are heavy-tailed but exhibit more nuanced behaviour than obtained by BA model\n\n## Constructing a new preference function\n\n:::{.notes}\nSo clearly we need to move beyond the standard preferential attachment or BA model\n- Inspired by the piecewise model from earlier which showed promising results for modelling empirical degrees\n\nWe propose a piecewise preference function that\n- Incorporates the polynomial behaviour from earlier\n- But is guaranteed the be linear in the limit\n:::\n\nWe require something that is eventually linear but is flexible enough for real networks\n\n\n::::::{.columns}\n\n:::::{.column width=\"50%\"}\n\n::::{.r-stack}\n:::{.fragment .fade-out fragment-index=1}\n**Barabási-Albert**\n$$\nb(k) = k+1\n$$\n:::\n\n:::{.fragment .fade-in fragment-index=1}\n**Proposed Model**\n$$\nb(k) = \\begin{cases}\nk^\\alpha + \\varepsilon, &k\\le k_0\\\\\nk_0^\\alpha + \\varepsilon + \\beta(k-k_0), &k>k_0\n\\end{cases}\n$$\n:::\n\n::::\n:::::\n\n\n:::::{.column width=\"50%\"}\n::::{.r-stack height=\"50%\"}\n:::{.fragment .fade-out fragment-index=1}\n```{r}\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\nx = seq(0,10,l=100)\ny = x+1\n\nggplot() + geom_line(aes(x=x,y=y), lwd=1)+ylim(0,10) + theme_classic() +theme(aspect.ratio = 1,plot.background = element_rect(fill=NA, color = NA),panel.background = element_rect(fill=NA, color = NA),axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank(), axis.title = element_text(size=20)) + xlab('Degree') + ylab('Preference')\n```\n:::\n\n\n:::{.fragment .fade-in fragment-index=1}\n\n```{r}\nlibrary(ggbrace)\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\nk0=5\na = 0.6\nb= 1\neps = 2\nx = seq(0,10,l=100)\ny = ifelse(x<k0, x^a + eps, k0^a + eps + b*(x-k0))\n\nx = seq(0,10,l=100)\nk0 = 5\na = 0.5\neps = 0.5\ny2 = ifelse(x<=k0, (eps + x^1) , (x-k0) + k0^1 + eps) +  (k0^a - k0)\ny3 = ifelse(x<=k0, (eps + x^a), (x-k0) + k0^a + eps)\ny4 = eps + x^a\n\ntextsize = 10\nlwd = 1\nggplot() +\n  geom_line(aes(x=x,y= y3), lwd=lwd) + \n  geom_segment(aes(x=k0, y=0.3,yend=eps + k0^a), lty=2, lwd=lwd)+\n  geom_text(aes(x=k0, y=0, label='k[0]'), parse = TRUE, size=textsize)+\n  geom_text(aes(x=6.3, y=4.3, label='beta'), parse=TRUE, size=textsize)+\n  stat_brace(aes(x=c(0, 0), y=c(0, eps)), rotate=90, width=0.2)+\n  geom_text(aes(x=2, y=2.3, label='alpha'), parse=TRUE, size=textsize)+\n  geom_text(aes(x=0.5, y=eps/2, label='epsilon'), parse=TRUE, size=textsize)+ theme_classic() +theme(aspect.ratio = 1,plot.background = element_rect(fill=NA, color = NA),panel.background = element_rect(fill=NA, color = NA),axis.text.x=element_blank(),axis.ticks.x=element_blank(),axis.text.y=element_blank(),axis.ticks.y=element_blank(), axis.title = element_text(size=20)) + xlab('Degree') + ylab('Preference')\n```\n:::\n::::\n:::::\n::::::\n\n::::{.r-stack}\n\n:::{.fragment .fade-out fragment-index=1}\n$$\n\\bar F(k) = \\frac{2}{(k+2)(k+3)}\n$$\n:::\n\n:::{.fragment .fade-in fragment-index=1}\n$$\n\\bar F(k) = \\begin{cases}\n\\prod_{i=0}^{k}\\frac{i^\\alpha + \\varepsilon}{\\lambda^*+i^\\alpha + \\varepsilon},&k\\le k_0,\\\\\n\\left(\\prod_{i=0}^{k_0-1}\\frac{i^\\alpha + \\varepsilon}{\\lambda^*+i^\\alpha + \\varepsilon}\\right)\\frac{\\Gamma(\\lambda^*+k_0^\\alpha + \\varepsilon)/\\beta)}{\\Gamma\\left((k_0^\\alpha + \\varepsilon)/\\beta\\right)} \\frac{\\Gamma\\left(k-k_0 + 1 +\\frac{k_0^\\alpha + \\varepsilon}{\\beta}\\right)}{\\Gamma\\left(k-k_0 + 1 +\\frac{\\lambda^* +k_0^\\alpha + \\varepsilon}{\\beta}\\right)},&k > k_0,\n\\end{cases}\n$$\n:::\n\n::::\n\n\n## Shape of degree distribution\n\n:::{.notes}\nShown here are some examples of the shape of distributions from the model with various parameter choices\n\nAll guaranteed to be in the  Fréchet, aligning with resultsf from @Lee24\n:::\n\n\n```{r}\n\nas = c(0.5,1,1.5)\nbs = c(0.5,1,1.5)\neps = c(.5,1)\nk0s = 20\nx = 0:200\npars = expand.grid(as,bs,eps,k0s,x)\nnames(pars) = c('a','b','eps','k0','x')\nlambdas = numeric(nrow(pars))\nfor(i in 1:nrow(pars)){\n  lambdas[i] = find_lambda2(polylin(pars$a[i], pars$eps[i]), pars$b[i], pars$k0[i])\n}\npars = cbind(pars,lambdas)\nnames(pars) = c('a', 'b', 'eps', 'k0','x','lambda')\nsurv =numeric(nrow(pars))\nfor(i in 1:nrow(pars)){\n  surv[i] = S(pars$x[i], polylin(pars$a[i], pars$eps[i]),pars$lambda[i], pars$k0[i],pars$b[i])\n}\npars = cbind(pars,surv)\nnames(pars) = c('a', 'b', 'eps', 'k0','x','lambda','surv')\n\nlibrary(latex2exp)\nlabeller = label_bquote(rows = `epsilon`==.(eps),cols = `alpha`==.(a))\n\n# pars[which.max(pars$b/lambdas),]\n# max(pars$b/lambdas)\n\nggplot(data = pars) + geom_line(aes(x=(x+1),y=surv, linetype=as.character(b),colour =as.character(b))) +\n  scale_x_log10() + scale_y_log10(limits=c(1e-5,1))+theme(aspect.ratio = 1/2) + theme_bw()+\n  theme(panel.background = element_rect(fill=NA, color=NA), plot.background = element_rect(fill=NA, color=NA),\n  legend.background = element_rect(fill=NA, color=NA), legend.box.background = element_rect(fill=NA, color=NA))+\n   xlab('Degree')  +ylab('Survival') + labs(linetype=TeX('\\\\beta'), colour =TeX('\\\\beta')) + \n  facet_grid(eps~a,labeller = labeller, scales='free')\n```\n\n## Tail behaviour\n\n:::{.notes}\nHere are some heatmaps of the tail indices for various parameter choices and how they change with respect to (,)\n- the red line indicates those parameter choices that give the same tail index as the BA model\n:::\n\n```{r}\n#| fig-width: 8\n#| fig-height: 4\n\nrho_optim_ba= Vectorize(function(a,eps, b, k0){\n  return(abs(rho(2*b, polylin(a, eps), b, k0)-1))\n},vectorize.args = 'a')\nfind_a_ba = Vectorize(function(b, eps, k0){\n  out = optimise(rho_optim_ba, c(0.00001,3), b=b, eps=eps, k0=k0)$minimum\n  return(out)\n}, vectorize.args = 'b')\nN =50\nas = seq(0,2,l=N+1)[-1]\nbs = seq(0,2,l=N+1)[-1]\neps = c(.01,.1,.5,1)\nk0 = c(25,100)\npars = expand.grid(as,bs,eps,k0)\nnames(pars) = c('a', 'b', 'eps', 'k0')\nlambdas = numeric(nrow(pars))\na_for_ba = numeric(nrow(pars))\nfor(i in 1:nrow(pars)){\n  lambdas[i] = find_lambda2(polylin(pars$a[i], pars$eps[i]), pars$b[i], pars$k0[i])\n  a_for_ba[i] = find_a_ba(pars$b[i], pars$eps[i], pars$k0[i])\n}\npars = cbind(pars,lambdas,a_for_ba)\nnames(pars) = c('a', 'b', 'eps', 'k0','lambda','ba')\nlabeller = label_bquote(cols = `epsilon`==.(eps),rows = ~k[0]==.(k0))\n\nggplot(pars) + geom_raster(aes(x=a,y=b,fill=b/lambda)) +\n  geom_line(aes(x=ba, y=b),linetype='dashed', colour='red',lwd=1)+\n  scale_fill_paletteer_c(palette='grDevices::Blues',limits=c(0,1),direction=-1)+theme(aspect.ratio = 1)+ylim(min(bs), max(bs))+xlim(min(as), max(as))+\n  facet_grid(k0~eps,labeller = labeller) + labs(fill=TeX('\\\\lambda^*/\\\\beta')) + xlab(TeX('\\\\alpha')) + ylab(TeX('\\\\beta')) + theme_minimal() + theme(panel.background = element_rect(fill=NA, color=NA))\n```\n\n\nAll limiting degree distributions produced by this model are  Fréchet with tail-index $\\lambda^*/\\beta$.\n\n## Simulation Study - set up\n\n:::{.notes}\nTo investigate the link betweent he preference function and the degrees\n\n- Do a simulation study to establish if the parameters are identifiable from only the degrees\n\n:::\n \n1. Simulate networks\n2. Use likelihood to fit model\n3. Recover parameters\n\n### The simulated data\n\n- 100,000 nodes\n- 36 parameter combinations\n- $k_0$ fixed at $20$\n- Only using final degrees\n\n---\n\n### The likelihood\n\n$$\n\\begin{aligned}\nL(\\pmb n | \\pmb \\theta,l) = &\\left(\\frac{\\lambda^*}{\\lambda^*+\\varepsilon}\\right)^{n_0}\\left(\\prod_{j=l}^{k_0-1}\\frac{j^\\alpha +\\varepsilon}{\\lambda^* + j^\\alpha +\\varepsilon}\\right)^{\\left(\\sum_{i\\ge k_0}n_{i}\\right)} \\\\ &\\times \\prod_{l \\le i<k_0}\\left(\\frac{\\lambda^*}{\\lambda^* +i^\\alpha + \\varepsilon } \\prod_{j=l}^{k_0-1}\\frac{j^\\alpha + \\varepsilon}{\\lambda^* + j^\\alpha + \\varepsilon}\\right)^{n_i}\\\\ &\\times \\prod_{i\\ge k_0}\\left(\\frac{\\text{B}(i-k_0 + (k_0^\\alpha + \\varepsilon)/\\beta,1+\\lambda^*/\\beta)}{\\text{B}((k_0^\\alpha + \\varepsilon)/\\beta,\\lambda^*/\\beta)}\\right)^{n_i},\n\\end{aligned}\n$$\n\n\n### Priors\n\n\\begin{align*}\n\\alpha&\\sim \\text{Gamma}(1,0.01),\\\\\n\\beta &\\sim  \\text{Gamma}(1,0.01),\\\\\nk_0 &\\sim \\text{U}(1,10,000),\\\\\n\\varepsilon &\\sim \\text{Gamma(1,0.01)},\n\\end{align*}\n\nNow we use an adaptive Metropolis-Hastings to obtain posterior samples\n\n\n## Model fits\n\n:::{.notes}\n Here are some example of the model fitted to some of the simulated data\n\n - This is the posterior survival obtained from the posterior samples of the parameters\n - 95% CI is very narrow and almost not visible\n\n:::\n\n\n```{r, cache=TRUE}\n\nsurfit_list = list()\npars = readRDS('results/recovery_pars.rds')\nrecovery_list = readRDS('results/recovery_dat.rds')\nselected = c(1,27,14,35)\n# selected = 1:36\nfor(k in 1:length(selected)){\n  j=selected[k]\n  x = recovery_list[[j]]$mcmc$dat[,1]\n  ls = c()\n\n  y_975 = recovery_list[[j]]$mcmc$surv$CI[2,][order(x)]\n  y_025 = recovery_list[[j]]$mcmc$surv$CI[1,][order(x)]\n  y_50 = recovery_list[[j]]$mcmc$surv$est[order(x)]\n  x = sort(x)\n  surfit_list[[k]] = ggplot() + geom_point(data=twbfn::deg_surv(recovery_list[[j]]$degs), aes(x=degree, y=surv)) +\n    geom_line(data=NULL, aes(x=!!x, y=!!y_975), colour = 'red', linetype='dashed')+\n    geom_line(data=NULL, aes(x=!!x, y=!!y_50),colour='red')+\n    geom_line(data=NULL, aes(x=!!x, y=!!y_025), colour = 'red', linetype='dashed')+\n    scale_x_log10(limits=c(1,1e5))  +scale_y_log10(limits = c(1/length(recovery_list[[j]]$degs),1))+theme_bw() + theme(aspect.ratio = 0.66,axis.title.y=element_blank(),                                                                   axis.text.y=element_blank(),                                                                     axis.ticks.y=element_blank()) + xlab('')+ylab('') +\n    ggtitle(TeX(paste0('$\\\\alpha = $',pars$a[j],\n                       ', $\\\\epsilon = $',pars$eps[j],\n                       ', $\\\\beta = $',pars$b[j]))) + theme(panel.background = element_rect(fill=NA, color=NA),\n                       plot.background = element_rect(fill=NA, color=NA))\n}\n\nfig = ggpubr::ggarrange(plotlist = surfit_list,\n          nrow=round(sqrt(length(surfit_list)),0),ncol=round(sqrt(length(surfit_list)),0),\n          label.x='Degree', label.y = 'Survival')\n\n\nggpubr::annotate_figure(fig, bottom='Degree', left='Survival')\n```\n\n\n```{r, fig.asp=0.5, fig.dpi=100, cache=FALSE, out.width='75%', message=FALSE,dev = \"png\"}\n\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\n\n\nlibrary(ggridges)\n\nrecover_pars = readRDS('results/recovery_pars.rds')\nrecovery_list = readRDS('results/recovery_dat.rds')\n\nthin.by = 5\nselected = c(\n  which(recover_pars$a%in%c(0.5,1,1.5) & \n          recover_pars$eps%in%c(0.1,0.5,1.0) &\n          recover_pars$b%in%c(0.1,0.5,1.0,1.5))\n)\n\nselected = unique(selected)\nfull_pars = recovery_list[[1]]$mcmc$smps\n\n\nfor(i in 2:length(recovery_list)){\n  full_pars = rbind(full_pars, recovery_list[[i]]$mcmc$smps)\n}\nnewtheme =  theme(aspect.ratio = 1, axis.title.x = element_blank(), axis.title.y =element_blank(), legend.position = 'none',\n          text = element_text(size = 20),plot.background = element_rect(fill=NA, color = NA),\n          panel.background = element_rect(fill=NA, color = NA), legend.background = element_rect(fill=NA),\n          element_text(angle = 90, vjust = 0.5, hjust=1))\nlibrary(latex2exp)\nlibrary(ggridges)\n\n\nlabeller = label_bquote(cols = `epsilon`==.(true_eps),rows = `alpha`==.(true_a))\npeps = ggplot(data=full_pars) + geom_density_ridges(aes(x=eps,y=as.character(true_b), fill = as.character(true_b))) +geom_point(aes(x=true_eps, y=as.character(true_b)))+\n  xlab(TeX('\\\\epsilon'))+ylab(TeX(''))+labs(fill=TeX('\\\\beta'))+\n  facet_grid(true_a~true_eps ,labeller=labeller, scales='fixed')+ theme(aspect.ratio = .3,axis.title.y=element_blank(),\n                                                                       axis.text.y=element_blank(),\n                                                                       axis.ticks.y=element_blank()) + theme_bw()+ newtheme+\n  scale_x_continuous(limits = c(0,1.5), breaks=c(0,0.5,1))\n  \n\nlabeller = label_bquote(cols = `epsilon`==.(true_eps),rows = `alpha`==.(true_a))\npk0 = ggplot(data=full_pars) + stat_binline(aes(x=k0,y=as.character(true_b), fill = as.character(true_b)),binwidth = 1) +geom_point(aes(x=true_k0, y=as.character(true_b)))+\n  xlab(TeX('$k_0$'))+ylab(TeX(''))+labs(fill=TeX('\\\\beta'))+xlim(0,200)+\n  facet_grid(true_a~true_eps ,labeller=labeller, scales='fixed')+ theme(aspect.ratio = 0.3,axis.title.y=element_blank(),\n                                                                       axis.text.y=element_blank(),\n                                                                       axis.ticks.y=element_blank()) + theme_bw()+ newtheme+\n  scale_x_continuous(limits = c(0,40), breaks=c(0,20,40))\n\nlabeller = label_bquote(cols = `epsilon`==.(true_eps),rows = `alpha`==.(true_a))\npb=ggplot(data=full_pars) + geom_density_ridges(aes(x=b,y=as.character(true_b), fill = as.character(true_b))) +geom_point(aes(x=true_b, y=as.character(true_b)))+\n  xlab(TeX('\\\\beta'))+ylab('')+labs(fill=TeX('\\\\beta'))+\n  facet_grid(true_a~true_eps ,labeller=labeller, scales='fixed') + theme(aspect.ratio = .3,axis.title.y=element_blank(),\n                                                                        axis.text.y=element_blank(),\n                                                                        axis.ticks.y=element_blank()) + theme_bw() + newtheme+\n  scale_x_continuous(limits = c(0,2), breaks=c(0,1,2))\n# full_plot = ggpubr::ggarrange(pa,peps,pk0,pb,common.legend = T, nrow=2,ncol=2,legend='bottom' ) + ggpubr::bgcolor('#f1f1f1')\n\nlabeller = label_bquote(cols = `epsilon`==.(true_eps),rows = `alpha`==.(true_a))\n\npa = ggplot(data=full_pars) + geom_density_ridges(aes(x=a,y=as.character(true_b), fill = as.character(true_b))) + geom_point(aes(x=true_a, y=as.character(true_b)))+xlim(0,2)+\n  xlab(TeX('\\\\alpha'))+ylab(TeX(''))+labs(fill=TeX('\\\\beta'))+\n  facet_grid(true_a~true_eps ,labeller=labeller, scales='fixed')+ theme(aspect.ratio = .3,axis.title.y=element_blank(),\n                                                                       axis.text.y=element_blank(),\n                                                                       axis.ticks.y=element_blank()) + theme_bw()+ newtheme+\n  scale_x_continuous(limits = c(0,2), breaks=c(0,1,2))\n\n\n```\n\n## The results\n\n:::{.notes}\nIn the following slides we show that the model parameters are recovered well from the degrees\n- In most cases highly concentrated around the true values\n- Cases where they are not are either because the threshold value is not reached in the simulation or an identifiability issue\n  - alpha=beta=1 can identify the threshold or it goes to zero/max(data) and alpha/beta becomes a free parameter\n:::\n\n#### Posterior of $\\alpha$  {style=\"text-align: center;font-size: 200%  !important;\"}\n\n```{r, fig.asp=.5, fig.dpi=100, cache=FALSE, out.width='75%', message=FALSE,dev = \"png\"}\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\npa\n```\n## The results\n\n#### Posterior of $\\varepsilon$  {style=\"text-align: center;font-size: 200%  !important;\"}\n\n```{r, fig.asp=.5, fig.dpi=100, cache=FALSE, out.width='75%', message=FALSE,dev = \"png\"}\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\npeps\n```\n\n## The results\n\n#### Posterior of  $k_0$  {style=\"text-align: center;font-size: 200%  !important;\"}\n\n\n```{r, fig.asp=.5, fig.dpi=100, cache=FALSE, out.width='75%', message=FALSE,dev = \"png\"}\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\npk0\n```\n\n## The results\n\n####  Posterior of $\\beta$ {style=\"text-align: center;font-size: 200%  !important;\"}\n\n```{r, fig.asp=.5, cache=FALSE,fig.dpi=100, out.width='75%', message=FALSE,dev = \"png\"}\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\n\npb\n```\n\n\n\n\n## Real Data\n\n\n:::{.notes}\nGiven the promising results from the sim study showing that parameters can be recovered from the degrees alone\n- we now apply to empirical networks\n\nWe compare the performance of this model to that of the discrete pw model.\n:::\n\n:::{.columns}\n\n::::{.column style=\"width:33%;text-align:center;\"}\n {{< fa globe size=3x title=''>}}\n \n Internet\n::::\n\n::::{.column style=\"width:33%;text-align:center;\"}\n {{< fa plane size=3x title=''>}}\n \n Flights\n::::\n\n::::{.column style=\"width:33%;text-align:center;\"}\n {{< fa y size=3x title=''>}}\n \n Proteins\n::::\n:::\n\n:::{style=\"text-align:center;\"}\n\nData sourced from [Network Data Repository](https://networkrepository.com/)[@nr]\n\nWe will fit the model and compare it to the mixture model.\n:::\n\n\n\n\n## 95% CI of survival function\n\n:::{.notes}\nwe can see that the model performs similarly and sometimes better than the pw model and captures the tail especially well\n:::\n\n```{r, warning=FALSE}\n#| fig-width: 4\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\nmixfits = readRDS('results/mixfits.rds')\nfits = readRDS('results/modelfits.rds')\nnms = readRDS('results/nms.rds')\nplots = list()\nselected = c(1,8,10)\n\nfor(j in 1:length(selected)){\n  i = selected[j]\n  udf = as.data.frame(table(fits[[i]]$smps$k0))\n  udf$Var1 = as.numeric(as.character(udf$Var1))\n  sdf = twbfn::deg_surv(counts_to_degs(dat_list[[i]]))\n  ptrunc = sdf$surv[sdf$degree==min(fits[[i]]$dat[,1])]\n  ptrunc_mix = sdf$surv[sdf$degree==min(mixfits[[i]]$data[,1])]\n  plots[[j]] = ggplot() + scale_x_log10(limits = c(1, max(dat_list[[i]][,1]))) + scale_y_log10(limits=c(1/sum(dat_list[[i]][,2]),1)) +\n    geom_segment(aes(x = jitter(!!fits[[i]]$smps$k0[seq(1,length(fits[[i]]$smps$k0),by=20)]),yend=0.5,y=1, colour='GPA'), alpha=0.1)+\n    geom_segment(data=NULL,aes(x = jitter(mixfits[[i]]$pars$u[seq(1,length(mixfits[[i]]$pars$u),by=20)]),yend=0.5,y=1, colour='Discrete Piecewise '), alpha=0.5)+\n    geom_point(data = twbfn::deg_surv(counts_to_degs(dat_list[[i]])),aes(x=degree, y=surv))+\n    geom_line(aes(x=!!fits[[i]]$dat[,1],y=!!fits[[i]]$surv$est*!!ptrunc/fits[[i]]$surv$est[1], colour='GPA')) + \n    geom_line(aes(x=!!fits[[i]]$dat[,1],y= !!fits[[i]]$surv$CI[1,]*!!ptrunc/fits[[i]]$surv$CI[1,1], colour='GPA'),linetype=2) + \n    geom_line(aes(x=!!fits[[i]]$dat[,1],y= !!fits[[i]]$surv$CI[2,]*!!ptrunc/fits[[i]]$surv$CI[2,1], colour='GPA'),linetype=2)+\n    geom_line(data = mixfits[[i]]$fitted,aes(x=x, y=S_975*!!ptrunc_mix/S_975[1], colour='Discrete Piecewise '), lty=2)+\n    geom_line(data = mixfits[[i]]$fitted,aes(x=x, y=S_025*!!ptrunc_mix/S_025[1], colour='Discrete Piecewise '),lty=2)+\n    geom_line(data = mixfits[[i]]$fitted,aes(x=x, y=S_med*!!ptrunc_mix/S_med[1], colour='Discrete Piecewise '))+\n    theme_minimal()+\n    labs(colour='Model')+theme(legend.position=\"bottom\",legend.title=element_blank())\n leg = get_legend(plots[[j]])\n legplot = ggpubr::as_ggplot(leg)\n plots[[j]] = plots[[j]] + theme(aspect.ratio = 1, axis.title.x = element_blank(), axis.title.y =element_blank(), legend.position = 'none',\n                      text = element_text(size = 20),plot.background = element_rect(fill=NA, color = NA), panel.background = element_rect(fill=NA, color = NA), plot.margin=grid::unit(c(0,0,0,0), \"mm\"))\n    \n}\n\n\n# comp_plot = ggpubr::ggarrange(plotlist = plots,common.legend = T,label.x = 'Degree', label.y = 'Survival',legend = 'bottom', nrow=1)\n\n```\n\n\n:::{.columns}\n\n::::{.column style=\"text-align: center; width:33%;\"}\n\n{{<fa globe>}}\n```{r, warning=FALSE, fig.asp=1 }\n\nplots[[1]]+ theme(text=element_text(size=35))\n```\n::::\n::::{.column style=\"text-align: center;width:33%;\"}\n{{<fa plane>}}\n```{r, warning=FALSE, fig.asp=1 }\n\nplots[[2]]+ theme(text=element_text(size=35))\n```\n\n```{r, fig.asp=0.5 }\n\nknitr::opts_chunk$set(dev.args = list(bg = \"transparent\"))\nlegplot = ggplot(data.frame(x = c(1,1), y = c(1,1), colour = c('PA', 'Discrete Piecewise ')),\n       aes(x, y, fill = colour)) +\n  geom_point(shape = 21, size = 0) +  # use a shape that uses fill\n  guides(fill = guide_legend(override.aes = list(size = 10)))  +\n  theme(\n    axis.title = element_blank(),\n    axis.text = element_blank(),\n    axis.ticks = element_blank(),\n    legend.position = c(.5, .5),\n    legend.direction = 'horizontal',\n    legend.title = element_blank(),\n    legend.text = element_text(size = 30),\n    legend.key = element_rect(fill = NA),\n    panel.grid = element_blank(),\n    plot.background = element_rect(fill=NA),\n    panel.background = element_rect(fill=NA),\n    plot.margin=grid::unit(c(0,0,0,0), \"mm\"),\n    panel.border = element_rect(colour = \"black\", fill = NA, size = 0),\n    legend.background = element_rect(fill=NA)\n  )\n```\n\n::::\n::::{.column style=\"text-align: center;width:33%;\"}\n{{<fa y>}}\n```{r, warning=FALSE, fig.asp=1}\n\nplots[[3]]+ theme(text=element_text(size=35))\n```\n::::\n:::\n\n```{r, fig.dpi=70}\nlegplot\n```\n\n## 95% CI of preference function\n\n:::{.notes}\nBut we know now that by fitting this model we not only model the degree distribution\n- We are also getting estimates for the model parameters and therefore the preference function\n- The credible intervals are quite large but it is more information that simply the pw model\n\nInterpretation\n\n- Levelling off may suggest diminishing returns behaviour\n- Internet seems to be essentially a linear function and any gain in number of connections gives the same benefit no matter what\n- This lines up with existing literature on the structure of the internet.\n\n:::\n\n```{r, warning=FALSE}\npref = function(pars,x){\n  return(ifelse(x<=pars[3], x^pars[1] + pars[2], pars[3]^pars[1] + pars[2] + pars[4]*(x-pars[3])))\n}\nplts = list()\nfor(j in 1:length(selected)){\n  i = selected[j]\n  pars = fits[[i]]$smps\n  x = fits[[i]]$dat$x\n  \n  plots  = list()\n  PA_overlay = ggplot()\n  \n  pref_mat = apply(pars, 1, pref, x = x)\n  pref_CI = apply(pref_mat, 1, quantile, prob =c(0.025, 0.5, 0.975))\n  \n  plts[[j]] = ggplot() +\n    geom_line(aes(x=!!x, y=!!pref_CI[3,]), lty=2)+\n    geom_line(aes(x=!!x, y=!!pref_CI[2,]))+\n    geom_line(aes(x=!!x, y=!!pref_CI[1,]), lty=2)+\n    theme(aspect.ratio = 1, axis.title.x = element_blank(), axis.title.y =element_blank(), legend.position = 'none',\n          text = element_text(size = 20),plot.background = element_rect(fill=NA, color = NA),\n          panel.background = element_rect(fill=NA, color = NA),\n          plot.margin=grid::unit(c(0,0,0,0), \"mm\"))\n}\n\n\n```\n\n:::{.columns}\n\n::::{.column style=\"text-align: center; width:33%;\"}\n{{<fa globe>}}\n\n```{r, warning=FALSE, fig.asp=1 }\n\nplts[[1]] + theme(text=element_text(size=35))\n```\n\n::::\n\n::::{.column style=\"text-align: center; width:33%;\"}\n\n{{<fa plane>}}\n\n```{r, warning=FALSE, fig.asp=1 }\n\nplts[[2]]+ theme(text=element_text(size=35))\n```\n::::\n\n::::{.column style=\"text-align: center; width:33%;\"}\n{{<fa y>}}\n\n```{r, warning=FALSE, fig.asp=1 }\n\nplts[[3]] + theme(text=element_text(size=35))\n```\n::::\n\n:::\n\n## Key Results\n\n- Characterisation of degree distribution from preference function\n  - Eventually linear $\\rightarrow$  Fréchet (heavy tail)\n  - Sublinear and unbounded $\\rightarrow$ Gumbel (light tail)\n  - Bounded $\\rightarrow$ recoverable to Gumbel (light tail)\n- Proposed preference function gives tail-realistic degree distributions\n- Parameters recovered from degrees alone in simulated networks\n- Can learn about real networks growth from snapshot of degrees\n\n## Limitations and Future work\n\n- Theory based on trees, which real networks rarely are\n- Only consider degrees in the snapshot\n- Assume a fairly restrictive model (pure birth)\n\n- Look beyond just the degrees\n- Incorporate more complex behaviour into the growth model\n- Extend theory beyond that of trees\n\n\n## Thank you\n\n### arXiv pre-print \n```{r, out.width=\"20%\"}\nplot(qrcode::qr_code(\"https://arxiv.org/abs/2506.18726\"), col=c(NA,\"#432534\"))\n```\n\n### References\n\n\n\n","srcMarkdownNoYaml":""},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"svg","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"fig-bg":"transparent","engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","from":"markdown+emoji","include-in-header":{"text":"<style>\n.v-center-container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: 90%;\n}\n</style>\n"},"embed-resources":true,"toc":false,"toc-depth":1,"output-file":"pres.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.7.29","auto-stretch":true,"title":"Beyond Descriptive Modelling of Network Degrees: Tail-Realistic Preferential Attachment","author":[{"name":"Thomas Boughen"}],"date":"2025/10/31","date-format":"long","knitr":{"opts_chunk":{"R.options":{"echo":false,"message":false,"warning":false}}},"bibliography":["refs.bib"],"self_contained":true,"mathjax":{"extensions":["AMScd","centernot"],"macros":{"centernot":"\\mathrel{\\not\\kern-2pt}","centernotimplies":"\\mathrel{\\ooalign{\\hidewidth$\\not\\Rightarrow$\\hidewidth}}"}},"theme":["solarized","custom.scss"],"transition":"none","history":false,"progress":true,"hash-type":"number","width":1920,"height":1080,"maxScale":1,"slideNumber":"c/t","fontawesome":true,"background-size":"contain","footer":"Beyond the Descriptive Modelling of Degrees - Thomas Boughen"}}},"projectFormats":["revealjs"]}